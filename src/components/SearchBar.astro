---
import styles from './SearchBar.module.css';

// Pass styles to the client-side script via data attributes
const styleClasses = JSON.stringify({
  open: styles.open,
  hint: styles.hint,
  loading: styles.loading,
  noResults: styles.noResults,
  resultsList: styles.resultsList,
  resultItem: styles.resultItem,
  resultTitle: styles.resultTitle,
  resultExcerpt: styles.resultExcerpt,
  focused: styles.focused,
  shortcut: styles.shortcut,
});
---

<!-- Search trigger button -->
<button
  type="button"
  class={styles.searchButton}
  id="search-button"
  aria-label="Search site"
  aria-haspopup="dialog"
>
  <svg class={styles.searchIcon} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
  </svg>
  <span class={styles.shortcut} id="search-shortcut">
    <kbd>Cmd</kbd>+<kbd>K</kbd>
  </span>
</button>

<!-- Search modal -->
<div class={styles.overlay} id="search-overlay" role="presentation">
  <div
    class={styles.modal}
    role="dialog"
    aria-modal="true"
    aria-label="Site search"
    id="search-modal"
  >
    <div class={styles.modalHeader}>
      <div class={styles.searchInputWrapper}>
        <svg class={styles.searchInputIcon} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
        </svg>
        <label for="search-input" class="visually-hidden">Search</label>
        <input
          type="text"
          id="search-input"
          class={styles.searchInput}
          placeholder="Search..."
          autocomplete="off"
        />
      </div>
      <button
        type="button"
        class={styles.closeButton}
        id="search-close"
        aria-label="Close search"
      >
        <svg class={styles.closeIcon} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
        </svg>
      </button>
    </div>
    <div class={styles.results} id="search-results">
      <p class={styles.hint}>Start typing to search...</p>
    </div>
  </div>
</div>

<!-- Pass styles to client script -->
<script id="search-styles" type="application/json" set:html={styleClasses} />

<script is:inline>
  // Get style classes from embedded JSON
  const stylesScript = document.getElementById('search-styles');
  const styles = stylesScript ? JSON.parse(stylesScript.textContent || '{}') : {};

  // Elements
  const searchButton = document.getElementById('search-button');
  const searchOverlay = document.getElementById('search-overlay');
  const searchModal = document.getElementById('search-modal');
  const searchInput = document.getElementById('search-input');
  const searchClose = document.getElementById('search-close');
  const searchResults = document.getElementById('search-results');
  const shortcutSpan = document.getElementById('search-shortcut');

  // State
  let pagefind = null;
  let isOpen = false;
  let focusedIndex = -1;
  let results = [];

  // Update shortcut text based on platform
  if (shortcutSpan) {
    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
    shortcutSpan.innerHTML = isMac
      ? '<kbd>Cmd</kbd>+<kbd>K</kbd>'
      : '<kbd>Ctrl</kbd>+<kbd>K</kbd>';
  }

  // Initialize Pagefind (lazy load)
  async function initPagefind() {
    if (pagefind) return pagefind;
    try {
      pagefind = await import('/pagefind/pagefind.js');
      await pagefind.init();
      return pagefind;
    } catch (e) {
      console.error('Failed to load Pagefind:', e);
      return null;
    }
  }

  // Open modal
  function openSearch() {
    if (isOpen) return;
    isOpen = true;
    searchOverlay.classList.add(styles.open);
    searchInput.focus();
    document.body.style.overflow = 'hidden';
    initPagefind();
  }

  // Close modal
  function closeSearch() {
    if (!isOpen) return;
    isOpen = false;
    searchOverlay.classList.remove(styles.open);
    document.body.style.overflow = '';
    searchInput.value = '';
    searchResults.innerHTML = '<p class="' + styles.hint + '">Start typing to search...</p>';
    focusedIndex = -1;
    results = [];
    searchButton.focus();
  }

  // Perform search
  async function performSearch(query) {
    if (!searchResults) return;

    if (!query.trim()) {
      searchResults.innerHTML = '<p class="' + styles.hint + '">Start typing to search...</p>';
      results = [];
      focusedIndex = -1;
      return;
    }

    const pf = await initPagefind();
    if (!pf) {
      searchResults.innerHTML = '<p class="' + styles.noResults + '">Search is not available</p>';
      return;
    }

    searchResults.innerHTML = '<p class="' + styles.loading + '">Searching...</p>';

    try {
      const search = await pf.search(query);
      results = await Promise.all(
        search.results.slice(0, 10).map(function(r) { return r.data(); })
      );

      if (results.length === 0) {
        searchResults.innerHTML = '<p class="' + styles.noResults + '">No results found for "' + query + '"</p>';
        focusedIndex = -1;
        return;
      }

      let html = '<ul class="' + styles.resultsList + '" role="listbox" id="search-results-list" aria-label="Search results">';
      results.forEach(function(result, index) {
        const title = (result.meta && result.meta.title) || result.url;
        const excerpt = result.excerpt ? '<div class="' + styles.resultExcerpt + '">' + result.excerpt + '</div>' : '';
        html += '<li role="option" id="search-result-' + index + '" aria-selected="' + (index === focusedIndex) + '">';
        html += '<a href="' + result.url + '" class="' + styles.resultItem + '" data-index="' + index + '">';
        html += '<div class="' + styles.resultTitle + '">' + title + '</div>';
        html += excerpt;
        html += '</a></li>';
      });
      html += '</ul>';
      searchResults.innerHTML = html;
      focusedIndex = -1;
    } catch (e) {
      console.error('Search error:', e);
      searchResults.innerHTML = '<p class="' + styles.noResults + '">Search error occurred</p>';
    }
  }

  // Update focused result styling
  function updateFocusedResult() {
    const items = searchResults.querySelectorAll('.' + styles.resultItem);
    items.forEach(function(item, index) {
      if (index === focusedIndex) {
        item.classList.add(styles.focused);
        item.scrollIntoView({ block: 'nearest' });
      } else {
        item.classList.remove(styles.focused);
      }
    });

    if (focusedIndex >= 0) {
      searchInput.setAttribute('aria-activedescendant', 'search-result-' + focusedIndex);
    } else {
      searchInput.removeAttribute('aria-activedescendant');
    }
  }

  // Navigate to focused result
  function navigateToResult() {
    if (focusedIndex >= 0 && results[focusedIndex]) {
      window.location.href = results[focusedIndex].url;
    }
  }

  // Event listeners
  searchButton.addEventListener('click', openSearch);
  searchClose.addEventListener('click', closeSearch);

  searchOverlay.addEventListener('click', function(e) {
    if (e.target === searchOverlay) {
      closeSearch();
    }
  });

  // Search input with debounce
  let debounceTimer;
  searchInput.addEventListener('input', function(e) {
    const query = e.target.value;
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(function() { performSearch(query); }, 200);
  });

  // Keyboard navigation
  document.addEventListener('keydown', function(e) {
    // Cmd/Ctrl + K to open
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      if (isOpen) {
        closeSearch();
      } else {
        openSearch();
      }
      return;
    }

    if (!isOpen) return;

    // Escape to close
    if (e.key === 'Escape') {
      e.preventDefault();
      closeSearch();
      return;
    }

    // Arrow keys for navigation
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (results.length > 0) {
        focusedIndex = Math.min(focusedIndex + 1, results.length - 1);
        updateFocusedResult();
      }
      return;
    }

    if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (results.length > 0) {
        focusedIndex = Math.max(focusedIndex - 1, -1);
        updateFocusedResult();
      }
      return;
    }

    // Enter to navigate
    if (e.key === 'Enter' && focusedIndex >= 0) {
      e.preventDefault();
      navigateToResult();
      return;
    }
  });

  // Focus trap in modal
  searchModal.addEventListener('keydown', function(e) {
    if (e.key !== 'Tab') return;

    const focusableElements = searchModal.querySelectorAll('input, button, a[href]');
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    if (e.shiftKey) {
      if (document.activeElement === firstElement) {
        e.preventDefault();
        lastElement.focus();
      }
    } else {
      if (document.activeElement === lastElement) {
        e.preventDefault();
        firstElement.focus();
      }
    }
  });
</script>
